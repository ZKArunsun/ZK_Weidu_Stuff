DEFINE_ACTION_FUNCTION ADD_OR_RETRIEVE_STAT_EQ_VALUE_CONDITION STR_VAR VALUE = ~~ RET index  BEGIN
    OUTER_SET index = ~-1~
    COPY_EXISTING ~STATS.IDS~ override
        COUNT_2DA_ROWS 2 rows
        FOR (i = 0; i < rows; ++i) BEGIN
            READ_2DA_ENTRY i 1 2 state_label
            PATCH_IF ~%state_label%~ STRING_EQUAL_CASE ~%VALUE%~ BEGIN
            READ_2DA_ENTRY i 0 2 state_id
            SET stat_rank = state_id
            END
        END
    BUT_ONLY

    ACTION_IF FILE_CONTAINS_EVALUATED (~SPLPROT.2DA~ ~^.+[0-9]+_STAT(%VALUE%)=n\b~) BEGIN
        COPY_EXISTING ~SPLPROT.2DA~ override
        COUNT_2DA_ROWS 2 rows
        FOR (i = 0; i < rows; ++i) BEGIN
            READ_2DA_ENTRY i 0 2 state_label
            //PATCH_PRINT ~%state_label%~
            //PATCH_PRINT ~^.+[0-9]+_STAT(%VALUE%)=n\b~
            PATCH_IF !(~%state_label%~ STRING_MATCHES_REGEXP ~^[0-9]+_STAT(%VALUE%)=n\b~) BEGIN
                READ_2DA_ENTRY i 0 2 state_id
                LPF SUBSTRING INT_VAR start = 0 length = 3 STR_VAR string = EVAL ~%state_id%~ RET substring = substring END
                PATCH_IF !(~%substring%~ STRING_MATCHES_REGEXP ~^[0-9]+$~) BEGIN
                    //PATCH_PRINT ~%substring%~
                    SET index = substring
                END ELSE BEGIN 
                    LPF SUBSTRING INT_VAR start = 0 length = 2 STR_VAR string = EVAL ~%state_id%~ RET substring = substring END
                    PATCH_IF !(~%substring%~ STRING_MATCHES_REGEXP ~^[0-9]+$~) BEGIN
                        SET index = substring
                    END ELSE BEGIN 
                    LPF SUBSTRING INT_VAR start = 0 length = 1 STR_VAR string = EVAL ~%state_id%~ RET substring = substring END
                    PATCH_IF !(~%substring%~ STRING_MATCHES_REGEXP ~^[0-9]+$~) BEGIN
                        SET index = substring
                    END
                END
                END
                
            END
        END
        BUT_ONLY
    END ELSE BEGIN
        ACTION_IF (~%VALUE%~ STRING_EQUAL ~~) BEGIN FAIL ~Missing VALUE's label~ END ELSE BEGIN
        ACTION_IF ((~%VALUE%~ STRING_CONTAINS_REGEXP ~ ~) = 0) BEGIN FAIL ~VALUE's label cannot have spaces~ END ELSE BEGIN
        COPY_EXISTING ~SPLPROT.2DA~ override
        COUNT_2DA_ROWS 2 rows
        FOR (i = 0; i < rows+1; ++i) BEGIN
            READ_2DA_ENTRY i 0 1 state_id
            SET correct_length = INDEX(CASE_INSENSITIVE EXACT_MATCH ~_~ ~%state_id%~ )
            PATCH_IF(~correct_length~ != ~-1~) BEGIN
            LPF SUBSTRING INT_VAR start = 0 length = correct_length STR_VAR string = EVAL ~%state_id%~ RET substring = substring END
            SET $occupied_slot(~%substring%~) = 1
            END

        END
            FOR (i = 0; i < 256; ++i) BEGIN
            PATCH_IF (!VARIABLE_IS_SET $occupied_slot(~%i%~)) BEGIN
            SET index = i
            SET i = 256
            PATCH_IF index <= rows BEGIN
            INSERT_2DA_ROW index+3 1 ~%index%_STAT(%VALUE%)=n %stat_rank% -1 1~
            END ELSE BEGIN
            INSERT_2DA_ROW rows+3 1 ~%index%_STAT(%VALUE%)=n %stat_rank% -1 1~
            END
            END
            END
        PATCH_IF (index = ~-1~) BEGIN PATCH_FAIL ~No available slots in SPLPROT.2DA~ END
        BUT_ONLY
        END
        END
    END
END

DEFINE_PATCH_FUNCTION ADD_SPELL_HEADER
    INT_VAR
        type = 0
        location = 4
        target = 1
        target_number = 1
        range = 0
        minimum_level = 0
        casting_speed = 0
        projectile = 0

    STR_VAR 
        icon = 0

    BEGIN
        READ_LONG 0x6a effect_offset
        INSERT_BYTES effect_offset 0x28
        SET newOffset = effect_offset+0x28
        WRITE_LONG 0x6a newOffset
        SET header_length = effect_offset - 0x72
        SET header_count = header_length/0x28
        SET effect_sum = 0
        FOR(i=0; i<header_count;++i) BEGIN
            SET effect_rank_offset = 0x72+i*0x28 +0x1E
            READ_SHORT effect_rank_offset effect_number
            SET effect_sum = effect_sum + effect_number
        END
        READ_LONG 0x68 ability_number
        SET ability_number = ability_number+1
        WRITE_LONG 0x68 ability_number
        WRITE_BYTE effect_offset type
        WRITE_SHORT effect_offset + 2 location
        WRITE_ASCIIE effect_offset + 4 ~%icon%~
        WRITE_BYTE effect_offset + 12  target
        WRITE_BYTE effect_offset + 13  target_number
        WRITE_SHORT effect_offset + 14 range
        WRITE_SHORT effect_offset + 16 minimum_level
        WRITE_SHORT effect_offset + 18 casting_speed
        WRITE_SHORT effect_offset + 0x26 projectile
        WRITE_SHORT effect_offset + 0x20 effect_sum


    END

DEFINE_ACTION_FUNCTION SCALE_SPELL INT_VAR STEP_SIZE = 1 PIVOT_VALUE = 10 TARGET = 1  CHANGE_PER_STEP = 0 STAT_LOWER_LIMIT = 1 STAT_UPPER_LIMIT = 25 STR_VAR STAT = ~~ ORIGINAL_RESOURCE = ~~ NEW_RESOURCE_BASE = ~~ PARAMETER_TO_SCALE = ~~ DESCRIPTION = ~+~BEGIN
    /*
    * Purpose of the function:
    * This function modify one spell and create alternate versions of that spell where one of the parameters scale with a stat of the target. Example applications: 
    *   Make a saving throw on a spell harder if the caster has high intelligence
    *   Reduce the damage dealt to a target if their dexterity is high enough
    *   Increase the damage of a spell if the caster has high proficiency with a particular weapon or fighting style.
    *   Lower the duration of a spell if the caster is too drunk
    * This function cannot scale a spell for more than one statistic. If you need to do that, see MULTI_SCALE_SPELL.
    * PARAMETERS: 
        * STEP_SIZE: The range in which a spell will have the same effect.
        * PIVOT_VALUE: The stat value for which the spell will get the same effect as the old spell
        * TARGET: The target whose stat is taken into account. The values are the same as the target value for all opcodes, in particular opcode 326. 1 means that it will depend on the caster's stats.
        * CHANGE_PER_STEP and PARAMETER_TO_SCALE determine what parameter to scale, and by how much it scales for each step.
        * STAT is the stat used for scaling the spell
        *   Any stat present in STATS.IDS can be used. This includes all base stats, as well as, for instance, proficiencies or intoxication. If using a non-base stat, change STAT_LOWER_LIMIT and STAT_UPPER_LIMIT accordingly.
        * STAT_LOWER_LIMIT and STAT_UPPER_LIMIT are the minimum and maximum values allowed for a stat. 
        *   By default, for base stats, it ranges from 1 to 25. 
        *   If the scaling was based on the intoxication of the target, for example, then values should be set to 0 and 100 respectively, as intoxication ranges from 0 to 100.
        * ORIGINAL_RESOURCE is the spell to patch
        * NEW_RESOURCE_BASE is the base name of the resources created by this function. This function will create one spell per step. The naming convention is "NEW_RESOURCE_BASE" + the spell rank. The spell rank is A through Z for ranks 1 to 26, then 0 through 9 for ranks 27 to 36, then #,_,!,- for ranks 37 to 40. As such, the length limit for this parameter is 7.
        * DESCRIPTION is the new description of the spell. If starting with +, then the content after the + is added to the existing description. Otherwise, the description is overriden. By default, the description is unchanged.
    * Example Function Call:
        * LAF SCALE_SPELL INT_VAR STEP_SIZE = 4 PIVOT_VALUE = 10 TARGET = 1  CHANGE_PER_STEP = 1 STAT_LOWER_LIMIT = 1 STAT_UPPER_LIMIT = 25 STR_VAR STAT = ~INT~ ORIGINAL_RESOURCE = ~SPWI112~ NEW_RESOURCE_BASE = ~ZKWI112~ PARAMETER_TO_SCALE = ~DIE_SIZE~ DESCRIPTION = ~+ The Dice Size is increased (decreased) by 1 for every 4th point of intelligence above (below) 10.~END
        * This will increase (decrease) the dice size of Magic Missile by 1 for every 4th point of intelligence of the caster above (below) 10. The newly created spells will be named ZKWI112A through ZKWI112G.
    */
    //Sanity check on PARAMETER_TO_SCALE
    ACTION_IF !(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DURATION~ OR ~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_SIZE~ OR ~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_NUMBER~ OR ~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~SAVING_THROW~ OR ~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~AMOUNT~)
    BEGIN
        FAIL ~Accepted values for PARAMETER_TO_SCALE are limited to DURATION, DICE_SIZE, DICE_NUMBER, SAVING_THROW and AMOUNT~ 
    END
    //Verifying emptiness on required string values
    ACTION_IF ((~%STAT%~ STRING_EQUAL ~~) OR (~%ORIGINAL_RESOURCE%~ STRING_EQUAL ~~) OR (~%NEW_RESOURCE_BASE%~ STRING_EQUAL ~~)) BEGIN FAIL ~STAT, ORGINAL_RESOURCE and NEW_RESOURCE_BASE cannot be empty~ END
    //Calculation of the exact number of steps
    OUTER_SET UPPER_STEPS =  (STAT_UPPER_LIMIT - PIVOT_VALUE - STEP_SIZE+1) MODULO STEP_SIZE = 0?(STAT_UPPER_LIMIT - PIVOT_VALUE - STEP_SIZE+1)/STEP_SIZE:1+(STAT_UPPER_LIMIT - PIVOT_VALUE - STEP_SIZE+1)/STEP_SIZE
    OUTER_SET LOWER_STEPS =  (PIVOT_VALUE - STAT_LOWER_LIMIT - STEP_SIZE+1) MODULO STEP_SIZE = 0?(PIVOT_VALUE - STAT_LOWER_LIMIT - STEP_SIZE+1)/STEP_SIZE:1+(PIVOT_VALUE - STAT_LOWER_LIMIT - STEP_SIZE+1)/STEP_SIZE
    OUTER_SET NUMBER_OF_STEPS = UPPER_STEPS + LOWER_STEPS +1
    ACTION_IF (NUMBER_OF_STEPS>40) BEGIN FAIL ~Due to Resource naming limitations, only up to 40 steps are accepted. Please increase the step size so (STAT_UPPER_LIMIT-STAT_LOWER_LIMIT)/STEP_SIZE)=<40~ END
    ACTION_IF (STAT_UPPER_LIMIT<STAT_LOWER_LIMIT) BEGIN FAIL ~STAT_UPPER_LIMIT should be greater than STAT_LOWER_LIMIT~ END
    ACTION_IF (STRING_LENGTH ~%NEW_RESOURCE_BASE%~ > 7) BEGIN FAIL ~NEW_RESOURCE_BASE cannot exceed 7 characters. Value given: %NEW_RESOURCE_BASE%~ END
    ACTION_IF (!FILE_EXISTS_IN_GAME ~%ORIGINAL_RESOURCE%.SPL~) BEGIN FAIL ~%ORIGINAL_RESOURCE% not found in game~ END

    LAF ADD_OR_RETRIEVE_STAT_EQ_VALUE_CONDITION STR_VAR VALUE = EVAL ~%STAT%~ RET stat_index = index END
    //Defining Extra Characters. To move to 2DA
    COPY ~%MOD_FOLDER%/2da/chars.2da~  ~%MOD_FOLDER%/2da/chars.2da~
    FOR(k = 1;k<41;++k) BEGIN
        READ_2DA_ENTRY k - 1 0 1 extra_char
        SPRINT $extra_char("%k%")  "%extra_char%"
    END
    BUT_ONLY

    COPY_EXISTING ~%ORIGINAL_RESOURCE%.SPL~ override
    FOR (j = 1; j < NUMBER_OF_STEPS+1; ++j) BEGIN
        INNER_ACTION BEGIN
        OUTER_SPRINT current_char $extra_char("%j%")
        OUTER_SPRINT spell_name "%NEW_RESOURCE_BASE%"^"%current_char%"
        //PRINT "%spell_name%"
        COPY_EXISTING ~%ORIGINAL_RESOURCE%.SPL~  ~override/%spell_name%.SPL~
            SAY 0x8 #-1
            SAY 0xc #-1
            SAY 0x54 #-1
            SAY 0x50 #-1
            SET change_value = 0 - (LOWER_STEPS - j +1) * CHANGE_PER_STEP
            /*
            Ability Length: 0x28
            Effect Number Offset:0x1E
            */
            SET number_effects = 0
            READ_LONG 0x64 abilities_offset
            READ_SHORT 0x68 number_abilities
            FOR(i = 0; i < number_abilities; ++i) BEGIN
            READ_SHORT abilities_offset+i*0x28+0x1E local_number_effect
            SET number_effects = number_effects + local_number_effect
            END
            /*Effect length: 0x30
            DURATION: start +0x0E (14): Only if base duration is 6+, to a minimum of 6, if timing mode is 0
            DICE_SIZE: start + 0x20 (32): Only for damage, to a minimum of 1.
            DICE_NUMBER: start +0x1C (28): Only for damage, to a minimum of 1
            SAVING_THROW: start + 0x28 (40): Only if Save is not empty, to a minimum of -10
            AMOUNT: start +0x04 (4): Only for Damage, to a minimum of 0
            */
            READ_LONG 0x6a effect_offset
            READ_SHORT 0x70 number_global_effect

            PATCH_IF(i<LOWER_STEPS+1) BEGIN
            
            FOR(i = 0; i < number_effects; ++i) BEGIN
                SET local_effect_offset = effect_offset + (i+number_global_effect)*0x30
                READ_BYTE (local_effect_offset + 0x0C) local_timing_mode
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DURATION~ AND local_timing_mode = 0) BEGIN
                    READ_LONG (local_effect_offset +0x0E) local_duration
                    PATCH_IF(local_duration>6) BEGIN
                    PATCH_IF(local_duration + change_value>6) BEGIN
                        WRITE_LONG (local_effect_offset +0x0E) (local_duration + change_value)
                    END ELSE BEGIN
                        WRITE_LONG (local_effect_offset +0x0E) 6
                    END
                    END
                END
                READ_SHORT local_effect_offset local_opcode
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_SIZE~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x20) local_dice_size                 
                    PATCH_IF(local_dice_size + change_value>0) BEGIN
                    WRITE_LONG (local_effect_offset +0x20) (local_dice_size + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x20) 1
                    END                  
                END
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_NUMBER~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x1C) local_dice_number                 
                    PATCH_IF(local_dice_number + change_value>0) BEGIN
                    WRITE_LONG (local_effect_offset +0x1C) (local_dice_number + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x1C) 1
                    END                  
                END
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~AMOUNT~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x04) local_dice_number                 
                    PATCH_IF(local_dice_number + change_value>0 - 1) BEGIN
                    WRITE_LONG (local_effect_offset +0x04) (local_dice_number + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x04) 0
                    END                  
                END
                READ_BYTE (local_effect_offset + 0x24) local_save_type
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~SAVING_THROW~ AND local_save_type != 0) BEGIN
                    READ_SLONG (local_effect_offset +0x28) local_save_bonus                 
                    PATCH_IF(local_save_bonus + change_value>0 - 10) BEGIN
                    WRITE_LONG (local_effect_offset +0x28) (local_save_bonus + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x28) (0 - 10)
                    END                  
                END

            END
            END
            PATCH_IF(i>LOWER_STEPS+1) BEGIN 
                FOR(i = 0; i < number_effects; ++i) BEGIN
                SET local_effect_offset = effect_offset + i*0x30
                READ_BYTE (local_effect_offset + 0x0C) local_timing_mode
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DURATION~ AND local_timing_mode = 0) BEGIN
                    READ_LONG (local_effect_offset +0x0E) local_duration
                    PATCH_IF(local_duration>6) BEGIN
                    PATCH_IF(local_duration + change_value>6) BEGIN
                        WRITE_LONG (local_effect_offset +0x0E) (local_duration + change_value)
                    END ELSE BEGIN
                        WRITE_LONG (local_effect_offset +0x0E) 6
                    END
                    END
                END
                READ_SHORT local_effect_offset local_opcode
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_SIZE~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x20) local_dice_size                 
                    PATCH_IF(local_dice_size + change_value>0) BEGIN
                    WRITE_LONG (local_effect_offset +0x20) (local_dice_size + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x20) 1
                    END                  
                END
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~DICE_NUMBER~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x1C) local_dice_number                 
                    PATCH_IF(local_dice_number + change_value>0) BEGIN
                    WRITE_LONG (local_effect_offset +0x1C) (local_dice_number + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x1C) 1
                    END                  
                END
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~AMOUNT~ AND local_opcode = 12) BEGIN
                    READ_LONG (local_effect_offset +0x04) local_dice_number                 
                    PATCH_IF(local_dice_number + change_value>0 - 1) BEGIN
                    WRITE_LONG (local_effect_offset +0x04) (local_dice_number + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x04) 0
                    END                  
                END
                READ_BYTE (local_effect_offset + 0x24) local_save_type
                PATCH_IF(~%PARAMETER_TO_SCALE%~ STRING_EQUAL ~SAVING_THROW~ AND local_save_type != 0) BEGIN
                    READ_SLONG (local_effect_offset +0x28) local_save_bonus                 
                    PATCH_IF(local_save_bonus + change_value>0 - 10) BEGIN
                    WRITE_LONG (local_effect_offset +0x28) (local_save_bonus + change_value)
                    END ELSE BEGIN
                    WRITE_LONG (local_effect_offset +0x28) (0 - 10)
                    END                  
                END
            END
            END 
        END
    END
    READ_BYTE 0x72 type
    READ_BYTE 0x74 location
    READ_BYTE 0x7e target
    READ_BYTE 0x7f target_number
    READ_SHORT 0x80 range 
    READ_SHORT 0x84 casting_speed
    READ_ASCII 0x76 icon
    READ_LONG 0x50 string_reference
    PATCH_IF (DESCRIPTION STRING_MATCHES_REGEXP "^\+.*") BEGIN 
        GET_STRREF string_reference current_description
        SET string_length = STRING_LENGTH "%DESCRIPTION%"
        LPF SUBSTRING INT_VAR start = 1 length = string_length - 1 STR_VAR string = EVAL "%DESCRIPTION%" RET DESCRIPTION = substring END
        SPRINT current_description "%current_description%" ^ "%DESCRIPTION%"
        SAY 0x50 "%current_description%"
    END ELSE BEGIN 
        SAY 0x50 "%DESCRIPTION%"
    END

    LPF DELETE_SPELL_HEADER INT_VAR header_type = (0 - 1) END
    LPF ADD_SPELL_HEADER
        INT_VAR
        type = type
        location = location
        target = target
        target_number = target_number
        range = range
        minimum_level = 1
        casting_speed = casting_speed
        projectile = 1      
        STR_VAR 
        icon = EVAL ~%icon%~
        END
    FOR (j = STAT_LOWER_LIMIT; j < STAT_UPPER_LIMIT + 1; ++j) BEGIN
        SPRINT correct_spell ""
        PATCH_IF(j<PIVOT_VALUE) BEGIN
        SET number_of_steps_below_pivot = (PIVOT_VALUE - j)/STEP_SIZE
        SET correct_spell_rank = LOWER_STEPS + 1 - number_of_steps_below_pivot
        SPRINT correct_char $extra_char("%correct_spell_rank%")
        SPRINT correct_spell "%NEW_RESOURCE_BASE%"^"%correct_char%"
        END
        PATCH_IF(j=PIVOT_VALUE) BEGIN
        SET correct_spell_rank = LOWER_STEPS + 1
        SPRINT correct_char $extra_char("%correct_spell_rank%")
        SPRINT correct_spell "%NEW_RESOURCE_BASE%"^"%correct_char%"
        END
        PATCH_IF(j>PIVOT_VALUE) BEGIN
        SET number_of_steps_above_pivot = (j - PIVOT_VALUE)/STEP_SIZE
        SET correct_spell_rank = LOWER_STEPS + 1 + number_of_steps_above_pivot
        SPRINT correct_char $extra_char("%correct_spell_rank%")
        SPRINT correct_spell "%NEW_RESOURCE_BASE%"^"%correct_char%"
        END
        
        LPF ADD_SPELL_EFFECT
        INT_VAR
        opcode = 326
        target = TARGET 
        parameter2 = stat_index 
        parameter1 = j 
        header = 0
        STR_VAR
        resource = EVAL ~%correct_spell%~ END
    END

    
    END

DEFINE_ACTION_FUNCTION MULTI_SCALE_SPELL INT_VAR i = 1 STR_VAR TABLE_PATH = ~~   ORIGINAL_RESOURCE = ~~ NEW_RESOURCE_BASE = ~~ DESCRIPTION = ~+~ BEGIN
    /*
    This function fulfills the same role as SCALE_SPELL, except it allows scaling a spell with multiple stats at once.
    TABLE_PATH expects a path to a 2DA file that contains the instructions for the scaling.
    Please refer to SCALE_SPELL for the other parameters
    Note that the length of NEW_RESOURCE_BASE is further limited here: each scaling dimension uses another character in the name of the spell. The max length for NEW_RESOURCE_BASE is 8 - scaling dimension. 
    The expected format for the 2DA is as follows. Please refer to SCALE_SPELL for details on each parameter in this table
    STEP_SIZE PIVOT_VALUE TARGET CHANGE_PER_STEP STAT_LOWER_LIMIT STAT_UPPER_LIMIT STAT PARAMETER_TO_SCALE 
    4         10          1      1               1                25               INT  DICE_SIZE
    6         10          1      1               1                25               WIS  DICE_NUMBER
    */
    ACTION_IF (~%TABLE_PATH%~ STRING_MATCHES_REGEXP ~.*\.2da~) BEGIN FAIL ~TABLE_PATH must be a path to a 2da file~ END
    COPY "%TABLE_PATH%" "%TABLE_PATH%"
        COUNT_2DA_ROWS 7 row_count
        PATCH_IF (STRING_LENGTH ~%NEW_RESOURCE_BASE%~ + row_count - i> 8) BEGIN
            SET scaling_dimension = row_count - 1
            SET new_resource_length = STRING_LENGTH ~%NEW_RESOURCE_BASE%~
            SET max_dimension = 8 - new_resource_length
            PATCH_FAIL ~Maximum scaling dimension exceeded. For a NEW_RESOURCE_BASE '%NEW_RESOURCE_BASE%' with length %new_resource_length%, the maximum scaling dimension is %max_dimension%. Please reduce the length of NEW_RESOURCE_BASE length or the scaling dimension (number of scaling rows in %TABLE_PATH%. Current: %scaling_dimension%).~
        END    
        READ_2DA_ENTRY i 0 7 step_size
        READ_2DA_ENTRY i 1 7 pivot_value
        READ_2DA_ENTRY i 2 7 target 
        READ_2DA_ENTRY i 3 7 change_per_step
        READ_2DA_ENTRY i 4 7 stat_lower_limit
        READ_2DA_ENTRY i 5 7 stat_upper_limit
        READ_2DA_ENTRY i 6 7 stat
        READ_2DA_ENTRY i 7 7 parameter_to_scale
        INNER_ACTION BEGIN
            OUTER_SET UPPER_STEPS =  (stat_upper_limit - pivot_value - step_size + 1) MODULO step_size = 0?(stat_upper_limit - pivot_value - step_size + 1)/step_size:1 + (stat_upper_limit - pivot_value - step_size + 1)/step_size
            OUTER_SET LOWER_STEPS =  (pivot_value - stat_lower_limit - step_size + 1) MODULO step_size = 0?(pivot_value - stat_lower_limit - step_size + 1)/step_size:1 + (pivot_value - stat_lower_limit - step_size + 1)/step_size
            OUTER_SET NUMBER_OF_STEPS = UPPER_STEPS + LOWER_STEPS +1
            LAF SCALE_SPELL INT_VAR STEP_SIZE = step_size PIVOT_VALUE = pivot_value TARGET = target  CHANGE_PER_STEP = change_per_step STAT_LOWER_LIMIT = stat_lower_limit STAT_UPPER_LIMIT = stat_upper_limit STR_VAR STAT = EVAL ~%stat%~ ORIGINAL_RESOURCE = EVAL ~%ORIGINAL_RESOURCE%~ NEW_RESOURCE_BASE = EVAL ~%NEW_RESOURCE_BASE%~ PARAMETER_TO_SCALE = EVAL "%parameter_to_scale%" DESCRIPTION = EVAL ~%DESCRIPTION%~ END
            ACTION_IF(i < row_count - 1) BEGIN
            COPY ~%MOD_FOLDER%/2da/chars.2da~  ~%MOD_FOLDER%/2da/chars.2da~
                FOR(k = 1;k<41;++k) BEGIN
                READ_2DA_ENTRY k - 1 0 1 extra_char
                SPRINT $extra_char("%k%")  "%extra_char%"
                END
            OUTER_FOR (j = 1; j < NUMBER_OF_STEPS + 1; ++j) BEGIN
                OUTER_SPRINT current_char $extra_char("%j%")
                OUTER_SPRINT spell_name "%NEW_RESOURCE_BASE%"^"%current_char%"
            LAF MULTI_SCALE_SPELL INT_VAR i = i + 1 STR_VAR TABLE_PATH = EVAL "%TABLE_PATH%"   ORIGINAL_RESOURCE = EVAL ~%spell_name%~ NEW_RESOURCE_BASE = EVAL ~%spell_name%~ DESCRIPTION = ~%DESCRIPTION%~ END
            END
            END
        END
        BUT_ONLY
END

DEFINE_ACTION_FUNCTION SCALE_SPELL_WITH_LEVEL INT_VAR SCALING_START_LEVEL = 2 MAX_LEVEL = 20 STR_VAR TABLE_PATH = ~~ SPELL_TO_PATCH = ~~ DESCRIPTION = ~+~ BEGIN
    /*
    * Purpose of the function:
    * This function modify one spell and create alternate versions of that spell where one of the parameters scale with a stat of the target. Example applications: 
    *   Make a saving throw on a spell harder if the caster has high intelligence
    *   Reduce the damage dealt to a target if their dexterity is high enough
    *   Increase the damage of a spell if the caster has high proficiency with a particular weapon or fighting style.
    *   Lower the duration of a spell if the caster is too drunk
    * This function cannot scale a spell for more than one statistic. If you need to do that, see MULTI_SCALE_SPELL.
    * PARAMETERS: 
        * STEP_SIZE: The range in which a spell will have the same effect.
        * CHANGE_PER_STEP and PARAMETER_TO_SCALE determine what parameter to scale, and by how much it scales for each step.
        * SCALING_START_LEVEL is the first level at which the spell's effects should be increased.
        * MAX_LEVEL is the level at which the spell stops scaling.
        * SPELL_TO_PATCH is the spell to patch
        * DESCRIPTION is the new description of the spell. If starting with +, then the content after the + is added to the existing description. Otherwise, the description is overriden. By default, the description is unchanged.
    */

    //Sanity check on PARAMETER_TO_SCALE
    ACTION_IF (~%TABLE_PATH%~ STRING_MATCHES_REGEXP ~.*\.2da~) BEGIN FAIL ~TABLE_PATH must be a path to a 2da file~ END
    //Calculation of the exact number of steps
    ACTION_IF (!FILE_EXISTS_IN_GAME ~%SPELL_TO_PATCH%.SPL~) BEGIN FAIL ~%SPELL_TO_PATCH% not found in game~ END

    COPY_EXISTING ~%SPELL_TO_PATCH%.SPL~ override
        READ_BYTE 0x72 type
        READ_BYTE 0x74 location
        READ_BYTE 0x7e target
        READ_BYTE 0x7f target_number
        READ_SHORT 0x80 range 
        READ_SHORT 0x84 casting_speed
        READ_ASCII 0x76 icon
        READ_LONG 0x50 string_reference
        READ_LONG 0x6a effect_offset
        READ_SHORT 0x90 ability_number_of_effects
        READ_SHORT 0x92 effect_number_offset
        READ_SHORT 0x98 projectile
        SET ability_effect_offset = effect_offset + effect_number_offset*0x30

        PATCH_IF (DESCRIPTION STRING_MATCHES_REGEXP "^\+.*") BEGIN 
            GET_STRREF string_reference current_description
            SET string_length = STRING_LENGTH "%DESCRIPTION%"
            LPF SUBSTRING INT_VAR start = 1 length = string_length - 1 STR_VAR string = EVAL "%DESCRIPTION%" RET DESCRIPTION = substring END
            SPRINT current_description "%current_description%" ^ "%DESCRIPTION%"
            SAY 0x50 "%current_description%"
        END ELSE BEGIN 
            SAY 0x50 "%DESCRIPTION%"
        END
        FOR(i = 0; i<ability_number_of_effects; ++i) BEGIN
            READ_SHORT ability_effect_offset + i*0x30 opcode
            READ_BYTE ability_effect_offset + i*0x30 +0x2 effect_target
            READ_BYTE ability_effect_offset + i*0x30 +0x3 power
            READ_LONG ability_effect_offset + i*0x30 +0x4 parameter1
            READ_LONG ability_effect_offset + i*0x30 +0x8 parameter2
            READ_BYTE ability_effect_offset + i*0x30 +0xc timing
            READ_BYTE ability_effect_offset + i*0x30 +0xd dispel
            READ_LONG ability_effect_offset + i*0x30 +0xe duration
            READ_BYTE ability_effect_offset + i*0x30 +0x13 probability_low
            READ_BYTE ability_effect_offset + i*0x30 +0x12 probability_high
            READ_ASCII ability_effect_offset + i*0x30 +0x14 resource
            PATCH_IF("%resource%" STRING_EQUAL ~~) BEGIN
                SPRINT resource "0"
            END
            READ_LONG ability_effect_offset + i*0x30 +0x1c dice_number
            READ_LONG ability_effect_offset + i*0x30 +0x20 dice_size
            READ_LONG ability_effect_offset + i*0x30 +0x24 save_type
            READ_LONG ability_effect_offset + i*0x30 +0x28 save_bonus
            READ_LONG ability_effect_offset + i*0x30 +0x2c special
            INNER_ACTION BEGIN
                ACTION_IF(!FILE_EXISTS ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~) BEGIN
                    
                    COPY ~%MOD_FOLDER%/2da/empty_effect_table.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~
                        INSERT_2DA_ROW i+1 1 ~0 %opcode% %effect_target% %power% %parameter1% %parameter2% %timing% %dispel% %duration% %probability_low% %probability_high% %resource% %dice_number% %dice_size% %save_type% %save_bonus% %special%~
                
                END ELSE BEGIN 
                    COPY  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~
                        INSERT_2DA_ROW i+1 1 ~0 %opcode% %effect_target% %power% %parameter1% %parameter2% %timing% %dispel% %duration% %probability_low% %probability_high% %resource% %dice_number% %dice_size% %save_type% %save_bonus% %special%~
                
                END
                
            END
        END
        INNER_ACTION BEGIN
            COPY "%TABLE_PATH%" "%TABLE_PATH%"
                COUNT_2DA_ROWS 5 effect_scaling_number
                effect_scaling_number -=1
                FOR(i = 1; i < effect_scaling_number+1; ++i) BEGIN
                    
                    READ_2DA_ENTRY i 0 5 $effect_scale("%i%_min_level")
                    READ_2DA_ENTRY i 1 5 $effect_scale("%i%_max_level")
                    READ_2DA_ENTRY i 2 5 $effect_scale("%i%_step_size")
                    READ_2DA_ENTRY i 3 5 $effect_scale("%i%_change_per_step")
                    READ_2DA_ENTRY i 4 5 $effect_scale("%i%_parameter_to_scale")
                    READ_2DA_ENTRY i 5 5 $effect_scale("%i%_effect_number")
                END
            BUT_ONLY

            
                
            OUTER_FOR(j = SCALING_START_LEVEL; j<= MAX_LEVEL; ++j) BEGIN                     
                OUTER_SET previous_file = j = SCALING_START_LEVEL?1:j - 1

                COPY  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%previous_file%.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%j%.2da~
                    //PATCH_PRINT ~Number of effects in ability: %ability_number_of_effects%~
                    FOR(k = 1; k<=ability_number_of_effects; ++k) BEGIN
                        SET header = j + 1 - SCALING_START_LEVEL
                        //PATCH_PRINT ~Setting effect %k% to header %header%~
                        SET_2DA_ENTRY k 0 0 header
                        FOR(l = 1; l<effect_scaling_number+1; ++l) BEGIN
                            PATCH_IF(k = $effect_scale("%l%_effect_number") AND j>=$effect_scale("%l%_min_level") AND j<=$effect_scale("%l%_max_level")) BEGIN
                                READ_2DA_ENTRY k 5 5 local_timing_mode
                                SET change_value = (j - $effect_scale("%l%_min_level")) MODULO $effect_scale("%l%_step_size") = 0? $effect_scale("%l%_change_per_step"):0
                                //PATCH_PRINT "change_value: %change_value%"
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~DURATION~ AND local_timing_mode = 0) BEGIN
                                    READ_2DA_ENTRY k 8 8 local_duration
                                    PATCH_IF(local_duration>6) BEGIN
                                        PATCH_IF(local_duration + change_value>6) BEGIN
                                            SET_2DA_ENTRY k 8 8 local_duration + change_value
                                        END ELSE BEGIN
                                            SET_2DA_ENTRY k 8 8 6
                                        END
                                    END ELSE BEGIN
                                        PATCH_IF(local_duration + change_value>0) BEGIN
                                            SET_2DA_ENTRY k 8 8 local_duration + change_value
                                        END ELSE BEGIN
                                            SET_2DA_ENTRY k 8 8 0
                                        END
                                    END
                                END
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~DICE_SIZE~) BEGIN
                                    READ_2DA_ENTRY k 13 13 local_dice_size
                                    PATCH_IF(local_dice_size + change_value>0) BEGIN
                                        SET_2DA_ENTRY k 13 13 (local_dice_size + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 13 13 1
                                    END                  
                                END
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~DICE_NUMBER~) BEGIN
                                    READ_2DA_ENTRY k 12 12 local_dice_number
                                    PATCH_IF(local_dice_number + change_value>0) BEGIN
                                        SET_2DA_ENTRY k 12 12 (local_dice_number + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 12 12 1
                                    END                  
                                END
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~PARAMETER1~) BEGIN
                                    READ_2DA_ENTRY k 4 4 local_parameter_1                 
                                    PATCH_IF(local_parameter_1 + change_value>0 - 1) BEGIN
                                        SET_2DA_ENTRY k 4 4 (local_dice_number + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 4 4 (local_dice_number + change_value)
                                    END                  
                                END
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~PARAMETER2~) BEGIN
                                    READ_2DA_ENTRY k 5 5 local_parameter_1                 
                                    PATCH_IF(local_parameter_1 + change_value>0 - 1) BEGIN
                                        SET_2DA_ENTRY k 5 5 (local_dice_number + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 5 5 (local_dice_number + change_value)
                                    END                  
                                END
                                READ_2DA_ENTRY k 14 14 local_save_type
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~SAVING_THROW~ AND local_save_type != 0) BEGIN
                                    READ_2DA_ENTRY k 15 15 local_save_bonus                 
                                    PATCH_IF(local_save_bonus + change_value>0 - 10) BEGIN
                                        SET_2DA_ENTRY k 15 15 (local_save_bonus + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 15 15 (0 - 10)
                                    END                  
                                END
                                PATCH_IF($effect_scale("%l%_parameter_to_scale") STRING_EQUAL ~PROBABILITY_HIGH~) BEGIN
                                    READ_2DA_ENTRY k 10 10 local_probability_high
                                    PATCH_IF(local_probability_high + change_value<100) BEGIN
                                        SET_2DA_ENTRY k 10 10 (local_probability_high + change_value)
                                    END ELSE BEGIN
                                        SET_2DA_ENTRY k 10 10 100
                                    END                  
                                END
                            END
                        END
                    END
                   
            END
            OUTER_FOR(j = SCALING_START_LEVEL; j<=MAX_LEVEL; ++j) BEGIN                     
                COPY  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%j%.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%j%.2da~                    
                    REMOVE_2DA_ROW 0 0
                    
            END
            COPY  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.effects.2da~
                FOR(j = SCALING_START_LEVEL; j<= MAX_LEVEL; ++j) BEGIN                    
                    APPEND_FILE_EVALUATE TEXT ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%j%.2da~
                END
            DELETE  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.1.2da~

            OUTER_FOR (j = SCALING_START_LEVEL; j<= MAX_LEVEL; ++j) BEGIN
                DELETE  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.%j%.2da~
            END
        END


        
        FOR(i = 2; i<=50; ++i) BEGIN
            LPF DELETE_SPELL_HEADER INT_VAR header_type = (0 - 1) min_level = i END
        END
        FOR(i = SCALING_START_LEVEL; i<=MAX_LEVEL; ++i) BEGIN
            LPF ADD_SPELL_HEADER
            INT_VAR
            type = type
            location = location
            target = target
            target_number = target_number
            range = range
            minimum_level = i
            casting_speed = casting_speed
            projectile = projectile      
            STR_VAR 
            icon = EVAL ~%icon%~
            END
        END
    COPY  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.effects.2da~  ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.effects.2da~
        COUNT_2DA_ROWS 0 number_of_effects_to_create
        FOR(i=1; i<number_of_effects_to_create;++i) BEGIN
            READ_2DA_ENTRY i 0 0 $effects_to_create("%i%_header")
            PATCH_IF($effects_to_create("%i%_header") != 0) BEGIN
                READ_2DA_ENTRY i 1 0 $effects_to_create("%i%_opcode")
                READ_2DA_ENTRY i 2 0 $effects_to_create("%i%_target")
                READ_2DA_ENTRY i 3 0 $effects_to_create("%i%_power")
                READ_2DA_ENTRY i 4 0 $effects_to_create("%i%_parameter1")
                READ_2DA_ENTRY i 5 0 $effects_to_create("%i%_parameter2")
                READ_2DA_ENTRY i 6 0 $effects_to_create("%i%_timing")
                READ_2DA_ENTRY i 7 0 $effects_to_create("%i%_dispel")
                READ_2DA_ENTRY i 8 0 $effects_to_create("%i%_duration")
                READ_2DA_ENTRY i 9 0 $effects_to_create("%i%_probability_low")
                READ_2DA_ENTRY i 10 0 $effects_to_create("%i%_probability_high")
                READ_2DA_ENTRY i 11 0 $effects_to_create("%i%_resource")
                READ_2DA_ENTRY i 12 0 $effects_to_create("%i%_dice_number")
                READ_2DA_ENTRY i 13 0 $effects_to_create("%i%_dice_size")
                READ_2DA_ENTRY i 14 0 $effects_to_create("%i%_save_type")
                READ_2DA_ENTRY i 15 0 $effects_to_create("%i%_save_bonus")
                READ_2DA_ENTRY i 16 0 $effects_to_create("%i%_special")
            END
        END
    BUT_ONLY
    DELETE ~%MOD_FOLDER%/temp/2da/%SPELL_TO_PATCH%.effects.2da~
    

   
        COPY_EXISTING ~%SPELL_TO_PATCH%.SPL~ ~override/%SPELL_TO_PATCH%.SPL~
            FOR(i=1; i<number_of_effects_to_create;++i) BEGIN
            PATCH_IF($effects_to_create("%i%_header") != 0) BEGIN
                LPF ADD_SPELL_EFFECT
                    INT_VAR
                    opcode = $effects_to_create("%i%_opcode")
                    target = $effects_to_create("%i%_target")
                    power = $effects_to_create("%i%_power")
                    parameter1 = $effects_to_create("%i%_parameter1") 
                    parameter2 = $effects_to_create("%i%_parameter2")
                    timing = $effects_to_create("%i%_timing")
                    resist_dispel = $effects_to_create("%i%_dispel") 
                    duration = $effects_to_create("%i%_duration")
                    probability2 = $effects_to_create("%i%_probability_low")
                    probability1 = $effects_to_create("%i%_probability_high")
                    dicenumber = $effects_to_create("%i%_dice_number")
                    dicesize = $effects_to_create("%i%_dice_size")
                    savingthrow = $effects_to_create("%i%_save_type")
                    savebonus = $effects_to_create("%i%_save_bonus")
                    special = $effects_to_create("%i%_special")
                    header = $effects_to_create("%i%_header")+1
                    STR_VAR 
                    resource = $effects_to_create("%i%_resource")
                END
            END
    END
  

END